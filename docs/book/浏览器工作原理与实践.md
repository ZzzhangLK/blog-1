极客时间《浏览器工作原理与实践》

## 第一章 重要性及要学的知识 2021.11.24

前端 80%的难题都跟浏览器的工作原理有关。学习目的：知识点串连成线，连成网，形成自己的知识体系

站在用户角度衡量性能

1. 页面加载时间：1s 内看到关键内容，衡量指标，FP,FCP,FMP,LCP,FSP，TODO:如何收集及如何进行数据分析？
2. 页面响应时间：点击按钮，100ms 内响应，FID
3. 动画卡顿：60FPS

首屏显示涉及，DNS, HTTP, DOM 解析，CSS 阻塞，JavaScript 阻塞等技术因素

Node 是基于 Chrome 的 V8 引擎实现的。

前端技术如何针对这些核心诉求做演进的。

1. 脚本执行速度：

-   修订语言本身，ES6 ES20, TS
-   使用新语言 WebAssembly. TODO: 对 Webcomponents 做一些了解，是什么，解决了什么问题，适用哪些场景

2. 前端模块化：
   commonJS
   ES6 Module
   Webcomponents 涉及到的 Shadow DOM，HTML Templates。TODO: 对 Webcomponents 做一些了解，是什么，解决了什么问题，适用哪些场景
3. 渲染效率问题
   页面渲染存在一些问题，下一代布局方案 TODO:LayoutNG，渲染瘦身方案 TODO:Slim Paint.

## 第二章 chrome 架构 2021.11.25

设计高性能 web，需要了解网络流程，页面渲染流程，javascript 执行流程，网络完全理论。通过浏览器的多进程架构可以把知识串联起来。

线程和进程：进程是一个程序运行的实例。启动一个程序时，操作系统会为该程序创建一块内存，来存放代码，运行中的数据和一个执行任务。
之间的关系:

1. 进程中任一一个线程出错，会导致整个进程的崩溃
2. 线程之间共享进程中的数据
3. 当一个进程关闭后，会回收其做占用的内存
4. 进程之间的内容相互隔离，通过 IPC 进行通信，TODO:IPC 是啥

浏览器的发展历史：

1. 最初始的单进程架构，因为存在不稳定（一个线程崩溃了，则浏览器就崩溃了，），不流畅（如果 js 执行时间过长，则其他的任务就只能等待， 而且只有浏览器关掉才会有内存回收），不安全（可以访问操作系统，也可以插入恶意代码盗取账号）的问题，
2. 后来修改为为多进程架构，解决不稳定（一个进程崩溃了，不会影响其他的，），不流畅（很多任务都是在不同进程中执行的，关掉一个页面就会进行内存回收），不安全（每个进程都是一个安全沙箱，无法访问操作系统）的问题
   多进程：

-   浏览器进程：负责页面展示，用户交互，子进程管理，同时提供存储功能
-   渲染进程：JS, css，html 转化为网页，排版引擎 Blink，JS V8 引擎都是运行在该进程中。每个 tab 标签都会创建一个渲染进程。运行在沙箱模式下。
-   GPU 进程：最初是为了 3d css，后来使用其进行页面绘制，TODO:了解各进程之间是如何协作的
-   网络进程:
-   插件进程

存在的问题：1、更好的内存占用 2、更复杂的架构体系：浏览器各模块耦合性强，可拓展性差

3. 未来的浏览器架构，面向服务的架构。
   各模块做成独立的服务，每个服务运行在独立的进程中。访问服务必须使用定义好的接口，通过 IPC 来通信

## TCP 协议：如果保证页面文件安全完整送到浏览器 2021.11.26

FP: 从页面加载到开始绘制的时间。这是一个重要的衡量网络性能的指标。什么影响了它呢，一个因为就是网络加载速度。
数据是被拆成一个个数据包去进行传输的。

数据包的路程
数据如何送达主机：通过 IP，把数据包发给指定的电脑。IP 是网络层的协议，指计算机的地址。有了 IP 地址，一个数据包是就可以从主机 A 传到主机 B。
主机如何将数据包交给应用程序: UDP 通过端口号把数据包发给特定的应用程序
主机如何将数据包完成地交给应用程序：TCP，保证了数据完整性传输，它的连接分为 3 个阶段：建立连接，传输阶段，断开连接

UDP：传输速度快，但是有丢包和没有顺序的问题。适合在线视频和网络游戏等对速度要求很高的
邮件等对数据要求很高的，使用 UDP 会有问题，于是有了 TCP 协议
TCP 协议是面向链接，可靠的，面向字节流的传输协议，和 UDP 相比，它有以下有两点：

1. 丢包重传机制。发数据包的时候，还需要接收方在一定时间内发确认收到的消息，如何没有，就认为数据包丢失，重新发送。
2. 数据包排序机制。数据包的 TCP 都序号，在收到后会按照序号重新排序组装数据包。

TCP 的传输过程

1. 建立连接：通过 3 次握手建立连接，即发 3 个数据包确认建立连接
2. 传输阶段：需要接收方进行数据确认操作。发数据包的时候，还需要接收方在一定时间内发确认收到的消息，如何没有，就认为数据包丢失，重新发送；接受方接受到数据后会按照 TCP 头部序号进行排序
3. 断开连接：通过 4 次挥手

TODO:为什么要是 3 次握手和 4 次挥手

HTTP 与 TCP，IP 的关系
HTTP 是应用层，TCP 是传输层，IP 是网络层
HTTP 在 TCP 之上，规定了传输数据包的数据格式。

## 从输入 URL 到页面展示 12.06

1. 浏览器解析用户输入的数据，判断是关键词还是域名，如果是关键词，则用默认的搜索引擎进行搜索，如果是域名则对域名进行补全
2. 浏览器进程会通过进程间通信（ipc）将 url 请求转发至网络进程
3. 网络进程会先查找本地缓存，如果没有，进入网络请求过程，DNS 解析获取 ip, https 需要建立 TLS 链接
4. 利用 ip 地址建立 TCP 链接，服务器接受到请求数据后，开始构建响应数据
5. 根绝状态码判断状态：301 和 302 则是需要进行重定向，根据响应头的 content-type 来判断如何解析，如果是下载类型 application/otcet-stream，则提交给浏览器的下载管理器处理，同时 url 的请求到此结束;则如果是页面，则类型为 text/html，则开始准备渲染进程了。
6. 浏览器根据响应包的数据，向渲染进程发起提交页面的请求

# 浏览器的页面循环系统

-   消息队列和事件循环
-   setTimeout
-   XMLHttpRequest
-   宏任务和微任务
-   Promise
-   async/await

关键词，问题，总结

## 消息队列和事件循环：页面时怎么“活”起来的

每个渲染进程都有一个主线程。它同时有很多不同类型的任务要处理，需要一个系统来调度，就是消息队列与事件循环系统。

-   使用单线程处理安排好的任务：按照顺序执行
-   在线程运行过程中处理新任务：循环机制
-   处理其他线程发送过来的任务：消息队列
-   处理其他进程发送过来的任务：渲染进程专门有一个 IO 线程来接收其他线程传过来的消息。先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程

消息队列中的任务类型

-   内部消息类型：如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等
-   和页面相关的事件：如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等
    问题：因为上面的任务都是在主线程中执行的，所以需要衡量事件所占用时长，并想办法解决单个任务占用时间过长的问题。

页面使用单线程的缺点：
页面线程执行的任务都来自于消息队列，消息队列先进先出的特点，会有两个问题

1. 如何处理高优先级的任务，如何权衡效率和实时性
   微任务。消息队列中的任务都是宏任务，每个宏任务都包含了一个微任务队列。
   效率：宏任务执行过程中产生的一些优先级高的任务会先放入其对应的微任务队列，这样不会影响当前宏任务的执行
   实时：执行完当前宏任务，会立即执行当前宏任务中的微任务列表
2. 单个任务执行时间过长问题
   通过回调功能。 也就是让要执行的 JavaScript 任务滞后执行。TODO:浏览器是如何实现回调功能的？

### 问题：

1. 浏览器页面主线程是如何运作的
2. 在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务
3. 微任务的作用是什么，为什么会有微任务，微任务如何权衡效率和实时性
   消息队列不太灵活，为了适用效率和实时性，引入了微任务。
4. 浏览器是如何实现回调功能的
5. TODO:requestAnimationFrame 的工作机制，并对比 setTimeout，然后分析出 requestAnimationFrame 实现的动画效果比 setTimeout 好的原因

## webAPI： setTimeout 是怎么实现的

下面通过 setTimeout 和 XMLHttpRequest 这两个 WebAPI 来介绍事件循环的应用

它是一个定时器，用来指定某个函数在多少毫秒之后执行。

浏览器怎么实现 setTimeout？
为了保证回调函数在指定时间被执行，不能将定时器的回调函数放在消息队列中。在消息队列之外，引入了延时队列：包括了定时器和 Chromium 内部一些需要延迟执行的任务。

消息循环系统是怎么触发延迟队列的？
处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。

适用 setTimeout 需要注意的问题

1. 如果当前任务执行时间过久，会影响定时器任务的执行
2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
4. 延时执行时间有最大值
5. setTimeout 设置的回调函数中的 this：如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。

-   适用匿名函数
-   适用 bind 方法

问题：

1. 浏览器怎么实现 setTimeout
   延时队列
2. 消息循环系统是怎么触发延迟队列的

## 任务调度：有了 setTimeout，为什么还要使用 requestAnimationFrame

渲染进程的任务调度系统？通过它，可以将渲染流水线和浏览器系统架构等知识串联起来，还有助于理解 devtool 的 Performance 标签是如何工作的。

-   任务调度系统
-   消息循环系统

但消息队列的队头阻塞问题，Chromium 是如何解决队头阻塞问题的？

-   什么是消息队列的队头阻塞问题：单消息队列在执行任务的时候是”先进先出“的，如果在执行过程中，用户点击了页面，这个时候如果队列里待执行的任务过多，那么处理点击时间就需要等待很久，用户就会感觉卡顿。
-   如何解决的
    -   1. 第一次迭代：引入高优先级队列。
           方式：渲染进程中引入一个任务调度器，从多个消息队列中找出合适的任务执行，按照顺序从高优先级的队列中取出任务执行，如果任务为空，则执行低优先级队列中的任务。
           存在的问题：任务需要保持相对执行顺序。比如输入消息和合成消息被添加不同优先级的队列。那么执行顺序就会打乱。可能会出现，还未处理点击事件，就合成了事件需要的图片。
    -   2. 第二次迭代：根据消息类型来实现消息队列。

其他知识拓展，fiber 的优先级实现借鉴了这个思想

## webAPI： XMLHttpRequest 是怎么实现的

XMLHttpRequest 是如何结合渲染进程中的循环系统工作的。

问题：

1. 通过 XMLHttpRequest 来讲解 1. 浏览器是如何实现 WebAPI 2.http 协议 3.安全问题
2. 跨域问题
3. https 内容混合问题

## 宏任务和微任务：不是所有任务都是一个待遇

1. 微任务是如何工作的
2. MutationObserver 是如何利用微任务来权衡性能和效率的

## Promise：使用 Promise，告别回调函数

微任务的另外一个应用 Promise。
学习一门技术，最好的方式是先了解这门技术是如何诞生的，以及它解决的问题是什么。

1. JavaScript 引入 Promise 的动机
   Promise 解决的是异步编码风格的问题。
   JavaScript 的异步编程模型。页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作
   页面编程的一个特点：异步回调。
   会引入回调地狱的问题。原因有两点： 1. 嵌套调用。下面任务依赖上一个任务的请求结果，在上个任务的回调函数中执行新的业务逻辑。 2. 任务的不确定性。每个任务都有两种可能性，成功或者失败，每个任务都要处理成功和失败两种情况。
   如何解决回调地狱：1. 消灭嵌套调用 2. 合并多个任务的错误处理。下面来看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。
2. 以及解决问题的几个核心关键点

-   消灭嵌套回调：
    -   实现回调函数的延时绑定：Promise 可以先创建完对象，再绑定函数。
    -   将回调函数 onResolve 的返回值穿透到最外层
-   处理异常：之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了

3.  promise 与微任务
    由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。

```js
function Bromise(executor) {
    var onResolve_ = null;
    var onReject_ = null;
    //模拟实现 resolve 和 then，暂不支持 rejcet
    this.then = function(onResolve, onReject) {
        onResolve_ = onResolve;
    };
    function resolve(value) {
        // 注意这部分的代码，如果没有这部分会报错： Uncaught TypeError: onResolve_ is not a function
        // 是由于 Bromise 的延迟绑定导致的，在调用到 onResolve_ 函数的时候，Bromise.then 还没有执行，所以执行上述代码的时候，当然会报“onResolve_ is not a function“的错误了
        // 要让 resolve 中的 onResolve_ 函数延后执行，可以在 resolve 函数里面加上一个定时器，让其延时执行 onResolve_ 函数
        setTimeout(() => {
            onResolve_ value;
        }, 0);
    }
    executor(resolve, null);
}

// 使用
function executor(resolve, reject) {
    resolve(100);
}
//将Promise改成我们自己的Bromsie
let demo = new Bromise(executor);

function onResolve(value) {
    console.log(value);
}
demo.then(onResolve);
```

可以使用定时器来推迟 onResolve 的执行，不过定时器效率不高，所有 Promise 就把它改成使用微任务了。

问题：

1. Promise 中为什么要引入微任务？
   由于 promise 采用.then 延时绑定回调机制，而 new Promise 时又需要直接执行 promise 中的方法，即发生了先执行方法后添加回调的过程，此时需等待 then 方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前 js 调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务
2. Promise 中是如何实现回调函数返回值穿透的？
   首先 Promise 的执行结果保存在 promise 的 data 变量中，然后是.then 方法返回值为使用 resolved 或 rejected 回调方法新建的一个 promise 对象，即例如成功则返回 new Promise（resolved），将前一个 promise 的 data 值赋给新建的 promise
3. Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？
   promise 内部有 resolved*和 rejected*变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断 rejected 参数是否为函数，若是函数，错误时使用 rejected 处理错误；若不是，则错误时直接 throw 错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听 unhandledrejection 事件捕获未处理的 promise 错误

## async/await：使用同步的方式去写异步代码

promise 虽然可以解决回调地狱的问题，但是同时也引入了新的问题。整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。
基于这个原因呢，引入了 async/await。提供了不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更清晰。

1. JavaScript 引擎是如何实现 async/await 的
   首先介绍生成器（Generator）是如何工作的，接着讲解 Generator 的底层实现机制——协程（Coroutine）；
   又因为 async/await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async/await 到底是如何以同步的方式来编写异步代码的

    ### 生成器 VS 协程

    生成器函数是一个带星号的函数，并且是可以暂停执行和恢复执行的。

    - JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的？要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。生成器是协程的一种实现方式。
      协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。
    - 父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈?
        1. gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。
        2. 当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。

2) 弄清楚 async 和 await 到底是怎么工作的

# 浏览器的页面

## chrome 开发者工具：利用网络面板（network）做性能分析

## chrome 开发者工具：利用 Audits 来优化加载阶段性能

Audits 会给出性能得分，也会给出优化建议。但是把很多细节都藏了起来。

## chrome 开发者工具：利用 performance 来做性能分析

Audits 只能监控加载阶段的性能数据，performance 不仅可以监控加载阶段的性能数据，还能监控交互阶段的性能数据。
performance 单纯的采集数据，并将采集到的数据按照时间线的方式展现。我们要做的是依据原始数据来分析 Web 应用的性能问题。
分为三个步骤：
第一步是配置 Performance；
第二步是生成报告页；
第三步就是人工分析报告页，并找出页面的性能瓶颈。

上面那个黑色按钮是用来记录交互阶段性能数据的，下面那个带箭头的圆圈形按钮用来记录加载阶段的性能数据。

-   当你录制加载阶段的性能数据时，Performance 会重新刷新页面，并等到页面完全渲染出来后，Performance 就会自动停止录制。
-   如果你是录制交互阶段的性能时，那么需要手动停止录制过程。

报告页分为 3 部分：

-   概览面板：Performance 就会将几个关键指标，诸如页面帧速 (FPS)、CPU 资源消耗、网络请求流量、V8 内存使用量 (堆内存) 等，按照时间顺序做成图表的形式展现出来，这就是概览面板。
    通过概览面板定位到可能存在问题的时间节点。接下来需要根据性能指标面板分析导致该问题的原因所在。
-   性能指标面板

    -   比如 `Main` 指标记录渲染主线程的任务执行过程，
    -   `Compositor` 指标记录了合成线程的任务执行过程，
    -   `GPU`指标记录了 GPU 进程主线程的任务执行过程。
        有了这些详细的性能数据，就可以帮助我们轻松地定位到页面的性能问题。

-   详情面板

时间线：Performance 按照时间线记录每个时间节点的性能数据，然后再按照时间顺序展示这些性能数据。比如上图中我们录制了 10000 毫秒，那么它的时间线长度也就是 10000 毫秒，体现在上图中就是概览面板最上面那条线

解读性能面板的各项指标
你需要掌握渲染流水线、浏览器进程架构、导航流程等知识点

-   渲染流水线：
    -   渲染模块在执行渲染的过程中会被划分为很多子阶段，输入的 HTML 数据经过这些子阶段，最后输出屏幕上的像素，我们把这样的一个处理流程叫做渲染流水线。
    -   一条完整的渲染流水线包括了解析 HTML 文件生成 DOM、解析 CSS 生成 CSSOM、执行 JavaScript、样式计算、构造布局树、准备绘制列表、光栅化、合成、显示等一系列操作
-   浏览器进程架构：
    -   渲染流水线主要是在渲染进程中执行的，在执行渲染流水线的过程中，渲染进程又需要网络进程、浏览器进程、GPU 等进程配合，才能完成如此复杂的任务。另外在渲染进程内部，又有很多线程来相互配合

## 问题记录

cookie 相关

-   httpOnly
-   samesite
-   如何删除

性能优化

如何使用
针对一些指标如何优化？

## 如何分析 performance 中的 Main 指标

## 目标

整理前端相关知识的目标：通过自己在实际开发中的遇到的问题和知识的运用，从这个技术解决了什么问题，为什么他可以解决，怎么解决的，这个思路出发，把零碎的知识点串联起来，形成自己完整的知识体系。也是为了需要的时候可以更好的进行记忆的提取。
大脑的神经网络依赖“关系型数据库”。也就是说所有的知识必须链接到已有的知识，到用的时候才能翻出来，否则就彻底失去索引找不回来了。

当心情烦躁，自我怀疑，不自信的时候，就写文字。记录自己乱糟糟的心情也好，看书做读书笔记也好，总之写文字，梳理自己的思维可以让可以安静下来。
晚上如何早睡。熬夜对自己的精神状态和身体都有很大的坏处。比如熬夜会让第二天基本就废掉了。
睡觉前不看新闻，不看电视剧，总之不让自己接受新的刺激。如果有很多想法或者很多事要做，就记录下来。把之前放在晚上做的事儿，放到早上来做。晚上下班回来如果还要逼自己学习的话，那肯定是无法接受的，因为工作了一天，已经很累了，要让自己做点放松的事情，比如看电影，锻炼身体，看自己喜欢的书籍。让自己早点休息。如果是学习，刷算法题，就留到第二天早上去做。

**本次复习，构建知识体系的关键在于关联**。和已有的知识关联，和平时写代码做项目时用到的技术关联。就像这次重新复习极客时间的这个课程，尝试从关联的角度去理解，发现就像之前从来没看过一样，但是实际上之前也看过两遍了，但是好像什么都没记住。希望这次从关联的角度去理解去记忆，下次搜索记忆的时候，可以搜到。

而且搞明白一些底层知识后，会发现很多都是想通的，比如技术的实现原理，很可能等你理解深刻之后，你会发现跟你平时做事，思考问题的原理是一样的。比如你的大脑是关系型数据库，比如原型链，当你遇到一个问题，可以得到一个解决答案时，一般你就不会深入的思考了，就跟在原型链上找属性时一样，找到了就立刻返回，不会接着往下找了。比如刻意培养阅读，思考的习惯，会很大地改变工作和日常生活。

同样，如果之后有时间，可以再按照这个思路，把一些值得反复看的经典书籍，包括技术书籍和其他书籍。

## 计划

尝试以金字塔的思维模型串联 《浏览器工作原理与实践》，并且运用认知天性里面提到的学习方法进行学习。

每次大考之前，不会一遍遍地看书，看笔记，而是拿出一张大纸，靠自己的回忆把这学期学习的公式、重点、单词、生字、诗词都默写一遍。每门课用一张纸。遇到想不起来的，就使劲想一会。最后再查书，补充完善这部分的知识图谱。
上面的这个套路称为：检索，间隔，巩固，细化，迁移.....
学习好不是靠天赋，而是有正确的方法，为什么靠记笔记和划线不能取得好成绩？因为那些方法没有给大脑带来挑战，没有起到巩固的作用，只会让人误认为自己掌握了。人们都不喜欢挑战自己，也不喜欢挫败感。相比较而言，一遍一遍地划线要轻松得多，可惜，轻松的学习是无效的。

比如自己回忆知识点的时候，发现自己什么都想不起来，就会感觉有很大的挫败感。而单纯地看笔记看书，觉得自己完全理解了，就会给自己一种自己已经掌握了的错觉。但是在考试的时候或者需要跟别人讲的时候，发现自己好像什么信息都提取不出来。

## 复习

将自己在本专栏中学习到的知识回忆一下。

pwa: 是一组技术的集合。

-   桌面打开：manifiest.json 文件进行配置
-   消息推送
-   离线存储： serverce worker，就是在加了一层代理，用作缓存。必须使用 Https。

===

webComponent：也是一组技术的集合。?从组件化入手
js 本来就是可以做隔离的，阻碍 组件化发展的是 html 和 css，所以需要解决 html 和 css 的隔离问题。引入 shadowDom 来解决。
如何实现 shadowDom 的，浏览器内部做了很多判断，查找元素或者 css 的时候，如果是 shadowDom 则直接跳过。存在的问题？
webComponent 主要有三部分.

-   customElements 自定义元素
-   shadowDom
-   html 模板

使用 webComponent 主要有三个步骤 代码：https://codepen.io/funnycoderstar/pen/BamxbyE

1. 使用 template 新建一个 模板
2. 创建一个 MyComponent 类：1.获取模板内容 2. 创建 shadowDOM 3. 将模板的内容插入到 shadowDOM 中

```js
class MyComponent extends HTMLElement {
    constructor() {
        super();
        // 获取组件模板
        const content = document.getElementById('myComponnnet').content;
        // 创造影子DOM
        const shadowDOM = this.attachShadow({ mode: 'open' });
        // 将模板添加到影子DOM上
        shadowDOM.appendChild(content.cloneNode(true));
    }
}
```

3. 使用 `customElements.define` 自定义元素, `customElements.define('my-component', MyComponent)`

浏览器如何实现影子 DOM

1. 影子 DOM 的 DOM 元素对整个网页不可见。在渲染引擎内部做判断，比如查找元素，如果是影子 DOM，则跳过
2. 影子 DOM 的 css 只作用于内部。生成布局树的时候也是这样判断的。

## 一段时间只做一件事儿

最近感觉很累。因为在做一件事的时候总会有新的事情冒出来。然后就总是被打断。这种状态好像都成为自己的习惯了。所以需要改掉这种习惯，让自己在一段时间内只沉浸做一件事儿。
怎么解决么? 可以使用番茄工作法

## 养成复习，总结的习惯

今天了解了一下语雀小记的这个功能的设计目的，就是为了记录平时的一些碎片化的思想，让自己不用顾忌放在哪个分类下，也不用在意格式，只要写就好了。这很像我现在使用 bear 的一个习惯，不知不觉，使用 bear 记录自己日常的一些所思所想已经过去一年了，不过从记录的内容其实是可以看到自己心态的变化的，也能注意到自己关注的事情的变化。

还有提到一个流程，小记是为了更好的把这些知识系统化串联起来。

## 浏览器中的页面

### 安全沙箱

一个标签页是一个进程。

## 浏览器中的 JS 执行机制

-   变量提升
-   执行上下文
-   作用域，作用域链
-   闭包

### 变量提升

```js
showName();
console.log(myname);
var myname = '极客时间';
function showName() {
    console.log('函数showName被执行');
}
```

js 的声明和赋值。
提前使用函数可以执行的得到正确的结果，提前使用变量得到的值为 undefined。
变量提升：js 执行过程中，js 引擎会把变量声明和函数声明的部分提前到代码开头的"行为", 会给赋值默认值 undefined，之所以需要实现变量提升，是因为 js 执行代码前需要先编译。

一段 JS 代码 -> 编译阶段 -> 执行阶段。

-   编译：生成两部分：执行上下文（包含变量环境，词法环境）和可执行代码。执行上下文就是 js 执行代码时的运行环境。
-   执行：按顺序执行可执行代码。

js 执行机制：先编辑，再执行。

### 哪些情况下的代码代码才会在执行前进行编译和创建执行上下文

-   执行上下文
-   调用栈

执行上下文是 js 执行一段代码的运行环境（存在一个变量环境的对象）。比如调用一个函数，就会进入到这个函数的执行上下文，确定该函数在执行期间用到的  诸如 this，变量，对象以及函数等。

1. 执行全局代码，会编译全局代码并创建全局上下文。在整个页面的生存周期内，只有一个全局上下文。
2. 调用函数时，函数体的代码会编译并创建函数上下文。一般情况下，函数执行完，即销毁。
3. eval 函数，eval 的代码也会编译，创建上下文。

```js
var a = 2;
function add(b, c) {
    return b + c;
}
function addAll(b, c) {
    var d = 10;
    result = add(b, c);
    return a + result + d;
}
addAll(3, 6);
```

调用栈是一个用来管理执行上下文的数据结构。

怎么查看函数的栈：

1. `console.trace();` 打印
2. 在 chrome 的 devtool 面板里的 `Source`面板，然后打断点，可以看到 Call Stack 模块就是

## 作用域

-   作用域：变量和函数的可访问范围
-   作用域链：查找变量，查找函数的流程
-   块级作用域：修复变量提升带来的问题

1.  变量容易在不被察觉的情况下被覆盖掉

```js
var myname = '小明';
function showName() {
    console.log(myname);
    if (0) {
        var myname = '小红';
    }
    console.log(myname);
}
showName();
```

打印结果为两次都是 undefined，为什么呢？
有两个执行上下文，一个是全局执行上下文，一个是函数的执行上下文。执行到 showName() 函数时，有两个 myname 变量，一个是在全局执行上下文，值为 `小明`，另一个是在函数的执行上下文中，由于变量提升，值为 undefined

2. 本应销毁的变量没有被销毁

```js
function foo() {
    for (var i = 0; i < 7; i++) {}
    console.log(i);
}
foo();
```

最后打印出来是 7。是因为在创建执行上下文阶段，变量 i 提升，所以当 for 循环结束后，变量 i 并没有被销毁。

在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？
站在执行上下文的角度，let 关键字是如何影响执行上下文的呢？
块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的，通过这两者的结合，js 引擎就同时支持了变量提升和块级作用域了。

> 上面两个代码的例子都是来自于 [阮一峰的 ECMAScript 6 入门文档中的代码](https://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F)

```js
let myname = '小明';
{
    console.log(myname);
    let myname = '小红';
}
```

结果：`ReferenceError: Cannot access 'myname' before initialization`。
在块作用域内，let 声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区（暂时性死区：在代码块内，使用 let 命令声明变量之前，该变量都是不可用的）

    分创建，初始化，赋值三个步骤。

-   var 的创建和初始化被提升，赋值不会被提升。
-   let 的创建被提升，初始化和赋值不会被提升。
-   function 的创建、初始化和赋值均会被提升。

问题：

1. 什么是作用域
2. ES6 是如何通过变量环境和词法环境来同时支持变量提升和块级作用域
3. 如何通过词法环境和变量环境来查找变量

### this：从 JavaScript 执行上下文的视角讲清楚 this

```js
var bar = {
    myName: 'bar的name',
    printName: function() {
        console.log(myName);
    },
};
function foo() {
    let myName = 'foo的name';
    return bar.printName;
}
let myName = '全局的name';
let _printName = foo();
_printName(); // 全局的name
bar.printName(); // 全局的name
```

在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 js 作用域机制并不支持这一点，所以又搞出一套 this 机制。

```js
var bar = {
    myName: 'bar的name',
    printName: function() {
        console.log(this.myName);
    },
};
bar.printName(); // bar的name
```

使用 this 实现，在对象的内部方法中使用对象的内部属性。
**作用域链和 this 是两套不同的系统，他们之间基本没太大关系**

### 各种相关名词之间的关系

我的疑问：调用栈，执行上下文，变量环境，词法环境，作用域，作用域链，词法作用域，块级作用域，闭包它们之间的关系

-   执行上下文：js 执行一段代码的运行环境
-   执行上下文包含变量环境(其中还包含一个对外部执行上下文的引用，outer)，词法环境，外部环境，this
-   调用栈是用来管理执行上下文的数据结构。
-   作用域：函数和变量的可访问范围。

    -   全局作用域
    -   函数作用域
    -   块级作用域：其代码内部定义的变量在代码块外部访问是访问不到的，且代码块中的代码执行完成后，代码会被销毁
    -   词法作用域：由代码中函数声明的位置来决定

-   作用域链：用来查找变量的规则
-   闭包：可以有权访问另一个函数作用域的函数。

## this

this 是和执行上下文绑定的，每个执行上下文都有一个 this。

-   eval 中的 this
-   全局执行上下文中的 this：
    全局执行上下文中，this 指向 window
    这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。
-   函数中的 this

```js
function foo() {
    console.log(this);
}
foo();
```

1.  在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的
2.  可以通过三种方式来设置函数执行上下文中的 this

-   call，apply，bind
-   通过对对象调用的方式： 使用对象调用其内部的方法，该方法的 this 是指向对象本身的。

```js
var myObj = {
    name: 'myObj',
    showThis: function() {
        console.log(this);
    },
};
myObj.showThis();
```

可以理解为 js 引擎在执行`myObj.showThis();`时转化为了`myObj.showThis.call(myObj)`。

```js
var myObj = {
    name: '极客时间',
    showThis: function() {
        this.name = '极客邦';
        console.log(this);
    },
};
var foo = myObj.showThis;
foo();
```

执行这段代码，你会发现 this 又指向了全局 window 对象。
结论：

-   在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。
-   通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。

3. 通过构造函数中设置（new）

```js
function CreateObj() {
    this.name = 'myObj';
}
var myObj = new CreateObj();
```

执行 `new CreateObj()`，js 引擎做了四件事

-   首先创建一个空对象 tempObj；
-   接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；
-   然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；
-   最后返回 tempObj 对象。

### this 的设计缺陷及应对方案

1. 嵌套函数中的 this 不会从外层函数中继承

```js
var myObj = {
    name: 'myObj',
    showThis: function() {
        console.log(this);
        function bar() {
            console.log(this);
        }
        bar();
    },
};
myObj.showThis();
```

函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。这就是 JavaScript 中非常容易让人迷惑的地方之一，也是很多问题的源头。
你可以通过一个小技巧来解决这个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self。

```js
var myObj = {
    name: 'myObj',
    showThis: function() {
        console.log(this);
        var self = this;
        function bar() {
            self.name = 'myObj1';
        }
        bar();
    },
};
myObj.showThis();
console.log(myObj.name);
console.log(window.name);
```

这个方法的的本质是把 this 体系转换为了作用域的体系。
你也可以使用 ES6 中的箭头函数来解决这个问题。箭头函数不会创建自身的执行上下文。所以箭头函数 this 取决于它的外部函数

```js
var myObj = {
    name: '极客时间',
    showThis: function() {
        console.log(this);
        var bar = () => {
            this.name = '极客邦';
            console.log(this);
        };
        bar();
    },
};
myObj.showThis();
console.log(myObj.name);
console.log(window.name);
```

this 没有作用域的限制。这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。解决这个问题有两个思路

-   第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
-   第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。

2. 普通函数中的 this 默认指向全局对象 window
   因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。
   这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。

你应该已经发现我们将近一半的时间都是在谈 JavaScript 的各种缺陷，比如变量提升带来的问题、this 带来问题等。我认为了解一门语言的缺陷并不是为了否定它，相反是为了能更加深入地了解它。我们在谈论缺陷的过程中，还结合 JavaScript 的工作流程分析了出现这些缺陷的原因，以及避开这些缺陷的方法。掌握了这些，相信你今后在使用 JavaScript 的过程中会更加得心应手。

# 《影响力》权威

影响力可怕的一点在于，在我们身上很起作用，但是我们这种作用我们完全没有意识到。
相当于被骗了，但是还没意识到怎么被骗了。还高高兴兴的帮忙数钱。

头衔，衣着，标志。
如何保护自己
做好充分的思想准备。对权威保持高度的警觉。
棘手的问题，我们不想完全拒绝权威的影响力，有的时候我们还非常愿意受权威的影响。

什么时候应该听从权威的意见，什么时候不应该听从权威得意见。

这个权威是否是真正得专家。注意力集中在两个信息上

1. 权威得资格
2. 权威和我们手里的这个问题的关系
   这个权威是否会对我们说真话。

## 数据库的知识

## 积极的信念

## web3 文档

## webpack
