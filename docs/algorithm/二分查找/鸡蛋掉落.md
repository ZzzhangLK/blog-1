## 887. 鸡蛋掉落

给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

示例 1：

输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
如果它没碎，那么肯定能得出 f = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
示例 2：

输入：k = 2, n = 6
输出：3

## 代码

动态规划+二分查找

```js
/**
 * @param {number} k
 * @param {number} n
 * @return {number}
 */
var superEggDrop = function(k, n) {
    // dp[i][j]表示一共j个鸡蛋，从i层扔下去
    let dp = new Array(k + 1).fill(0).map(() => new Array(n + 1).fill(0));
    let j = 0;
    while (dp[k][j] < n) {
        j++;
        for (let i = 1; i <= k; i++) {
            // 状态：dp[i][j] 有i个鸡蛋，j次扔鸡蛋的测得的最多楼层
            // 转移方程：dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + 1
            // dp[i - 1][j - 1] 表示碎了，dp[i - 1][j]，表示没碎
            dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] + 1;
        }
    }
    return j;
};
```

[]()
