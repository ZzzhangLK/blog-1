## 题目

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列   是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

示例 2：

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

示例 3：

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解题思路

【最长递增子序列问题】非常经典的一个算法题。
使用动态规划来解题。动态规划的难点在于找寻正确的状态转移方程

1. `dp[i]`代表什么：`dp[i]`表示以 `nums[i]`这个数结尾的最长递增子序列的长度
2. base case: `dp[i]`的初始值为 `1`， 因为以`nums[i]`结尾的最长递增子序列起码要包含它自己
3. 怎么设计计算逻辑来正确计算每个`dp[i]`：
   假设已经知道 dp[0...4]的所有结果，如果通过已知结果推出`dp[5]`，`nums[5] = 3`, 既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。

    ```js
    for (let j = 0; j < i; j++) {
        // 找到上一个比i小的子串，拼接到后面
        if (nums[j] < nums[i]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    ```

```js
// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    // dp，初始值为1，因为dp[i]的上升子序列至少是它自己
    let dp = new Array(nums.length).fill(1);
    for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            // 找到上一个比i小的子串，拼接到后面
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    // 获取结果中最大的值
    return Math.max.apply(null, dp);
};
```

-   时间复杂度: O(n<sup>2<sup>)，需要两重循环
-   空间复杂度: O(n)，dp 数组占用的空间

### 总结

总结一下如何找到动态规划的状态转移关系：
1、明确 dp 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。
2、根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。
