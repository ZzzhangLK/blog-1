## 快速排序

-   在数组中选一个基准数（通常为数组第一个）。
-   将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边
-   对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。

快速排序又是一种分治的的思想在排序算法上的典型应用

### 写法一

浪费大量存储空间，写法简单

```js
function quickSort(arr) {
    if (arr.length < 2) {
        return arr;
    }
    let target = arr[0];
    // 单独开辟两个存储空间，left,right，存储每次递归比target大或小的序列
    let left = [];
    let right = [];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < target) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    // 每次递归直接返回left、target、right拼接后的数组
    return quickSort(left).concat([target], quickSort(right));
}
```

-   时间复杂度: 平均 O(nlogn)，极端情况下为 O(n<sup>2</sup>)

### 写法二

不需要额外存储空间，写法思路稍复杂

```js
function quickSort(arr, left, right) {
    if (right - left < 1) {
        return arr;
    }
    // 选择第一个作为基准值
    let target = arr[left];
    // 记录一个索引l从数组最左侧开始，记录一个索引r从数组右侧开始
    let l = left;
    let r = right;
    while (l < r) {
        // 在l<r的条件下，找到右侧小于target的值array[r]，并将其赋值到array[l]
        while (l < r && arr[r] >= target) {
            r--;
        }
        arr[l] = arr[r];
        // 在l<r的条件下，找到左侧大于target的值array[l]，并将其赋值到array[r]
        while (l < r && arr[l] < target) {
            l++;
        }
        arr[r] = arr[l];
    }
    // 这样当l=r时，l左侧的值全部小于target，l右侧的值全部小于target，将target放到该位置（l）
    arr[l] = target;
    // 缩小排序的范围，递归调用排序
    quickSort(arr, left, l - 1);
    quickSort(arr, l + 1, right);
    return arr;
}
```
