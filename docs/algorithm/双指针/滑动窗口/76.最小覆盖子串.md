```js
/*
 * @lc app=leetcode.cn id=76 lang=javascript
 *
 * [76] 最小覆盖子串
 */

// @lc code=start
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
    /** 使用滑动窗口，滑动窗口的思路
     * 1.滑动窗口的扩张（找到可行解）：左指针不动，右指针向右移动，直到找到可行解 -- 纳入所有目标字符
     * 2.滑动窗口的收缩（从可行解中找最优解）：右指针不动，左指针向右移动，直到窗口不再包含所有字符
     * 3.不断重复上述操作，直到窗口的右端到达边界
     */
    let minLen = s.length + 1;
    let start = s.length; // 结果子串的开始位置
    // 存储目标字符和对应的缺失个数
    let map = {};
    // 当前缺失的字符种类数
    let missingType = 0;
    for (const item of t) {
        // t为baac的话，map为{a:2,b:1,c:1}
        if (map[item]) {
            map[item]++;
        } else {
            missingType++; // 需要找齐的种类数 +1
            map[item] = 1;
        }
    }
    let left = 0;
    let right = 0;
    for (; right < s.length; right++) {
        // rightChar 是将移入窗口的字符
        let rightChar = s[right];
        if (map[rightChar] !== undefined) {
            map[rightChar]--;
        }
        // 它的缺失的个数变为0，缺失的种类就 - 1
        if (map[rightChar] === 0) {
            missingType--;
        }
        // 当前窗口包含所有字符的前提下，尽量收缩窗口
        while (missingType === 0) {
            // 窗口宽度比 minLen小，就更新minLen
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                // 更新最小窗口的起点
                start = left;
            }
            // 左指针需要右移，左指针指向的字符要丢弃
            let leftChar = s[left];
            if (map[leftChar] !== undefined) {
                map[leftChar]++;
            }
            if (map[leftChar] > 0) {
                // 如果缺失个数新变为>0，缺失的种类+1
                missingType++;
            }
            left++; // 左指针要右移，收缩窗口
        }
    }
    if (start === s.length) {
        return '';
    }
    return s.substring(start, start + minLen);
};
// @lc code=end
```
